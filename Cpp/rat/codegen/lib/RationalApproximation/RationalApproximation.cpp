//
// File: RationalApproximation.cpp
//
// MATLAB Coder version            : 5.1
// C/C++ source code generated on  : 17-Nov-2025 15:40:00
//

// Include Files
#include "RationalApproximation.h"
#include "rt_nonfinite.h"
#include "rt_nonfinite.h"
#include <cmath>
#include <math.h>

// Function Declarations
static double rt_roundd_snf(double u);

// Function Definitions
//
// Arguments    : double u
// Return Type  : double
//
static double rt_roundd_snf(double u)
{
  double y;
  if (std::abs(u) < 4.503599627370496E+15) {
    if (u >= 0.5) {
      y = std::floor(u + 0.5);
    } else if (u > -0.5) {
      y = u * 0.0;
    } else {
      y = std::ceil(u - 0.5);
    }
  } else {
    y = u;
  }

  return y;
}

//
// RAT    Rational approximation.
//    [N,D] = RAT(X,tol) returns two integer matrices so that
//    N./D is close to X in the sense that abs(N./D - X) <= tol.
//    The rational approximations are generated by truncating continued
//    fraction expansions.   tol = 1.e-6*norm(X(:),1) is the default.
//
//    S = RAT(X) or RAT(X,tol) returns the continued fraction
//    representation as a character array.
//
//    The same algorithm, with the default tol, is used internally
//    by MATLAB for FORMAT RAT.
//
//    Class support for input X:
//       float: double, single
//
//    See also FORMAT, RATS.
// Arguments    : double X
//                double tol
//                double *N
//                double *D
// Return Type  : void
//
void RationalApproximation(double X, double tol, double *N, double *D)
{
  double x;
  int exponent;
  boolean_T b;

  //    Copyright 1984-2019 The MathWorks, Inc.
  //  Approximate x by
  //
  //                               1
  //          d1 + ----------------------------------
  //                                  1
  //               d2 + -----------------------------
  //                                    1
  //                    d3 + ------------------------
  //                                       1
  //                         d4 + -------------------
  //                                         1
  //                              d5 + --------------
  //                                            1
  //                                   d6 + ---------
  //                                              1
  //                                        d7 + ----
  //                                              d8
  //
  //  The d's are obtained by repeatedly picking off the integer part and
  //  then taking the reciprocal of the fractional part.  The accuracy of
  //  the approximation increases exponentially with the number of terms
  //  and is worst when x = sqrt(2).  For x = sqrt(2), the error with k
  //  terms is about 2.68*(.173)^k, which is
  //
  //          1    4.6364e-01
  //          2    8.0210e-02
  //          3    1.3876e-02
  //          4    2.4006e-03
  //          5    4.1530e-04
  //          6    7.1847e-05
  //          7    1.2430e-05
  //          8    2.1503e-06
  //          9    3.7201e-07
  //         10    6.4357e-08
  x = X;
  b = rtIsNaN(X);
  if (rtIsInf(X) || b) {
    //  Special case for inf, -inf, NaN
    if (!b) {
      *N = X;
      if (X < 0.0) {
        *N = -1.0;
      } else if (X > 0.0) {
        *N = 1.0;
      } else {
        if (X == 0.0) {
          *N = 0.0;
        }
      }
    } else {
      *N = 0.0;
    }

    *D = 0.0;
  } else {
    double C_idx_0;
    double C_idx_1;
    double C_idx_2;
    double C_idx_3;
    C_idx_0 = 1.0;
    C_idx_1 = 0.0;
    C_idx_2 = 0.0;
    C_idx_3 = 1.0;

    //  [n(k) n(k-1); d(k) d(k-1)];
    double d;
    int exitg1;
    do {
      exitg1 = 0;
      d = rt_roundd_snf(x);
      if (!rtIsInf(x)) {
        double x_idx_2;
        double x_idx_3;
        x -= d;
        x_idx_2 = C_idx_0;
        x_idx_3 = C_idx_1;
        C_idx_0 = C_idx_0 * d + C_idx_2;
        C_idx_1 = C_idx_1 * d + C_idx_3;
        C_idx_2 = x_idx_2;
        C_idx_3 = x_idx_3;
      } else {
        double x_idx_2;
        double x_idx_3;

        //  Special case for +/- inf
        x_idx_2 = C_idx_0;
        x_idx_3 = C_idx_1;
        C_idx_0 = x;
        C_idx_1 = 0.0;
        C_idx_2 = x_idx_2;
        C_idx_3 = x_idx_3;
      }

      if (x == 0.0) {
        exitg1 = 1;
      } else {
        d = std::abs(X);
        if ((!rtIsInf(d)) && (!rtIsNaN(d))) {
          if (d <= 2.2250738585072014E-308) {
            d = 4.94065645841247E-324;
          } else {
            frexp(d, &exponent);
            d = std::ldexp(1.0, exponent - 53);
          }
        } else {
          d = rtNaN;
        }

        if ((tol > d) || rtIsNaN(d)) {
          d = tol;
        }

        if (std::abs(C_idx_0 / C_idx_1 - X) <= d) {
          exitg1 = 1;
        } else {
          x = 1.0 / x;
        }
      }
    } while (exitg1 == 0);

    x = C_idx_1;
    if (C_idx_1 < 0.0) {
      x = -1.0;
    } else if (C_idx_1 > 0.0) {
      x = 1.0;
    } else {
      if (C_idx_1 == 0.0) {
        x = 0.0;
      }
    }

    *N = C_idx_0 / x;
    *D = std::abs(C_idx_1);
  }
}

//
// File trailer for RationalApproximation.cpp
//
// [EOF]
//
